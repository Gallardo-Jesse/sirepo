
from rswarp.diagnostics import ImpactDensity

# use the function arr[0][0] + k * sk + l * sl (loop over k then l) to
# get the original array value
def _linear_fit_2d(arr):
    sk = (arr[len(arr) - 1][0] - arr[0][0]) / (len(arr) - 1)
    sl = (arr[0][len(arr[0]) - 1] - arr[0][0]) / (len(arr[0]) - 1)
    # test
    #rel_tol = 1e-6
    #for k in range(len(arr)):
    #    for l in range(len(arr[k])):
    #        cfn = arr[0][0] + k * sk + l * sl
    #        diff = abs(arr[k][l] - cfn) / arr[k][l]
    #        if diff > rel_tol:
    #            print('OOPS! array: {} vs fn: {}; diff {}'.format(arr[k][l], cfn, diff))
    return sk, sl

# use the function arr[0] + k * sk (loop over k) to
# get the original array value
def _linear_fit_1d(arr):
    sk = (arr[len(arr) - 1] - arr[0]) / (len(arr) - 1)
    # test
    #rel_tol = 1e-6
    #for k in range(len(arr)):
    #    cfn = arr[0] + k * sk
    #    diff = abs(arr[k] - cfn) / arr[k]
    #    if diff > rel_tol:
    #        print('OOPS! array: {} vs fn: {}; diff {}'.format(arr[k], cfn, diff))
    return sk

try:
    #print('SCRAPER {}'.format(wp.w3d))
    i_data = []
    plot_density = ImpactDensity.PlotDensity(None, None, scraper, wp.top, wp.w3d)

    if not hasattr(plot_density, 'conductors'):
        plot_density.gate_scraped_particles()
        plot_density.map_density()
        for gid in plot_density.gated_ids:
            for side in plot_density.gated_ids[gid]:
                del plot_density.gated_ids[gid][side]['interpolation']

        density_results = {
            'gated_ids': plot_density.gated_ids,
            'dx': plot_density.dx,
            'dz': plot_density.dz,
            'min': plot_density.cmap_normalization.vmin,
            'max': plot_density.cmap_normalization.vmax,
        }
    else:
        i_data = []
        for i in plot_density.conductors:
            c_data = []
            c = plot_density.conductors[i]
            {% if is3D %}
            coord_keys = ['x', 'y', 'z']
            d = plot_density.generate_plot_data_for_faces_3d(c)
            for (x, y, z, s) in d:
                f_data = {
                    'dArr': s.tolist()
                }
                #print('cond {}: S at x {} ({}/{}), y {} ({}/{}), z {} ({}/{}): {} ({}/{})'.format(i, x, len(x), len(x[0]), y, len(y), len(y[0]), z, len(z), len(z[0]), s, len(s), len(s[0])))
                for cx, coord in enumerate((x, y, z)):
                    sk, sl = _linear_fit_2d(coord)
                    f_data[coord_keys[cx]] = {
                        'startVal': coord[0][0],
                        'slopek': sk,
                        'slopel': sl
                    }
                c_data.append(f_data)
            {% else %}
            coord_keys = ['x', 'z']
            d = plot_density.generate_plot_data_for_faces_2d(c)
            for (x, z, s) in d:
                f_data = {
                    'dArr': s.tolist()
                }
                print('cond {}: S at x {} ({}), z {} ({}): {}'.format(i, x, len(x), z, len(z), s))
                for cx, coord in enumerate((x, z)):
                    sk = _linear_fit_1d(coord)
                    f_data[coord_keys[cx]] = {
                        'startVal': coord[0],
                        'slopek': sk
                    }
                c_data.append(f_data)
            {% endif %}
            i_data.append(c_data)

        density_results = {
            'dx': plot_density.dx,
            {% if is3D %}
             'dy': plot_density.dy,
            {% endif %}
            'dz': plot_density.dz,
            'density': i_data,
            'min': plot_density.cmap_normalization.vmin,
            'max': plot_density.cmap_normalization.vmax,
        }

except AssertionError as e:
    message = e.message
    if wp.top.npslost[0] <= 0:
        message = 'No particles made impact. Nothing to plot.'
    density_results = {
        'error': message,
    }
np.save('{{ densityFile }}', density_results)
