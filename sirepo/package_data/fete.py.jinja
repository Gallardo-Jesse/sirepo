from __future__ import absolute_import, division, print_function

import warpoptions
warpoptions.ignoreUnknownArgs = True

import sys
from warp import *
import numpy as np
import os

import rswarp
from warp.data_dumping.openpmd_diag import ParticleDiagnostic
from rswarp.diagnostics import FieldDiagnostic
from rswarp.cathode import sources
from rswarp.cathode import injectors

from scipy import constants
kb_eV = 8.6173324e-5 #Bolztmann constant in eV/K
kb_J = constants.k #Boltzmann constant in J/K

#-----

diagDir = 'diags/xzsolver/hdf5/'

#------

#GLOBAL GEOMETRY PARAMETERS FOR USERS
PLATE_SPACING = {{ simulationGrid_plate_spacing }}
CHANNEL_WIDTH = {{ simulationGrid_channel_width }} #width of simulation box

#Dimensions
X_MAX = CHANNEL_WIDTH*0.5
X_MIN = -1.*X_MAX
Y_MAX = CHANNEL_WIDTH*0.5
Y_MIN = -1.*Y_MAX
Z_MIN = 0.
Z_MAX = PLATE_SPACING

#Grid parameters
NUM_X = {{ simulationGrid_num_x }}
NUM_Y = 64
NUM_Z = {{ simulationGrid_num_z }}

#z step size
dz =  (Z_MAX - Z_MIN)/NUM_Z

#------

#Specify solver geometry
w3d.solvergeom = w3d.XZgeom

assert w3d.solvergeom == w3d.XZgeom, \
    'Solver geometry required to be w3d.XZgeom'

# Set boundary conditions
# Longitudinal conditions overriden by conducting plates
w3d.bound0  = neumann
w3d.boundnz = dirichlet
w3d.boundxy = periodic
# Particles boundary conditions
top.pbound0  = absorb
top.pboundnz = absorb
top.pboundxy = periodic

# Set grid boundaries
w3d.xmmin = X_MIN
w3d.xmmax = X_MAX
w3d.zmmin = 0.
w3d.zmmax = Z_MAX

# Set grid counts
w3d.nx = NUM_X
w3d.nz = NUM_Z

zmesh = np.linspace(0,Z_MAX,NUM_Z+1) #holds the z-axis grid points in an array

#------

#Cathode and anode settings
CATHODE_TEMP = {{ beam_cathode_temperature }} #cathode temperature in K
CATHODE_PHI = {{ beam_cathode_work_function }} #work function in eV
ANODE_WF = {{ beam_anode_work_function }}
GRID_BIAS = {{ beam_anode_voltage }} #voltage applied to any grid of electrodes

vacuum_level = CATHODE_PHI - ANODE_WF + GRID_BIAS

#compute beam cutoff velocity for time-step determinance
beam_beta = sources.compute_cutoff_beta(CATHODE_TEMP)

#Compute Child-Langmuir limit for this setup A/m^2
cl_limit = sources.cl_limit(CATHODE_PHI, ANODE_WF, GRID_BIAS, PLATE_SPACING)

#------

#INJECTION SPECIFICATION
USER_INJECT = {{ beam_currentMode }}

# --- Setup simulation species
beam = Species(type={{ beam_species }}, name='beam')

# --- Set basic beam parameters
SOURCE_RADIUS_1 = {{ beam_x_radius }} #a0 parameter - X plane
SOURCE_RADIUS_2 = 0.5*CHANNEL_WIDTH #b0 parameter - Y plane
Z_PART_MIN = {{ simulationGrid_z_particle_min }}


#Compute cathode area for geomtry-specific current calculations
if w3d.solvergeom == w3d.XYZgeom:
    #For 3D cartesion geometry only
    cathode_area = 4.*SOURCE_RADIUS_1*SOURCE_RADIUS_2
else:
    #Assume 2D XZ geometry
    cathode_area = 2.*SOURCE_RADIUS_1*1. # 1 m is the geometric factor scaling the plane of the ignorable coordinate

# If true, position and angle of injected particle are computed analytically rather than interpolated
# Can be false for all but C-L injection (inject=2)
w3d.l_inj_exact = False

#Specify particles to be injected each step
PTCL_PER_STEP = {{ simulationGrid_particles_per_step }}
top.npinject = PTCL_PER_STEP

# --- If using the XZ geometry, set so injection uses the same geometry
top.linj_rectangle = (w3d.solvergeom == w3d.XZgeom)

#Determine an appropriate time step based upon estimated final velocity
vzfinal = sqrt(2.*abs(vacuum_level)*np.abs(beam.charge)/beam.mass)+beam_beta*constants.c
dt = dz/vzfinal #5e-15
top.dt = dt

if vzfinal*top.dt > dz:
    print("Time step dt = {:.3e}s does not constrain motion to a single cell".format(top.dt))


if USER_INJECT == 1:
    # Constant current density - beam transverse velocity fixed to zero, very small longitduinal velocity

    #Set injection flag
    top.inject = 6               # 1 means constant; 2 means space-charge limited injection;# 6 means user-specified

    USER_CURRENT = {{ beam_beam_current }}
    beam.ibeam = USER_CURRENT
    beam.a0     = SOURCE_RADIUS_1
    beam.b0     = SOURCE_RADIUS_2

    #sources.constant_current(beam, CHANNEL_WIDTH, Z_PART_MIN, ptcl_per_step)
    myInjector = injectors.injectorUserDefined(beam, CATHODE_TEMP, CHANNEL_WIDTH, Z_PART_MIN, PTCL_PER_STEP)
    installuserinjection(myInjector.inject_constant)

if USER_INJECT == 2:
    # space charge limited injection using Child-Langmuir computation of cold limit

    #Set injection flag
    top.inject = 2               # 1 means constant; 2 means space-charge limited injection;# 6 means user-specified

    beam_current = sources.cl_limit(CATHODE_PHI, ANODE_WF, GRID_BIAS, PLATE_SPACING)*cathode_area
    beam.ibeam = beam_current
    beam.a0     = SOURCE_RADIUS_1
    beam.b0     = SOURCE_RADIUS_2
    w3d.l_inj_exact = True


elif USER_INJECT == 3:
    #Thermionic injection

    #Set injection flag
    top.inject = 6               # 1 means constant; 2 means space-charge limited injection;# 6 means user-specified

    beam_current = sources.j_rd(CATHODE_TEMP,CATHODE_PHI)*cathode_area #steady state current in Amps
    beam.ibeam = beam_current
    beam.a0     = SOURCE_RADIUS_1
    beam.b0     = SOURCE_RADIUS_2

    myInjector = injectors.injectorUserDefined(beam, CATHODE_TEMP, CHANNEL_WIDTH, Z_PART_MIN, PTCL_PER_STEP)
    installuserinjection(myInjector.inject_thermionic)

    # These must be set for user injection
    top.ainject = 1.0
    top.binject = 1.0


derivqty()

#------

# Set up fieldsolver
f3d.mgtol = 1e-6 # Multigrid solver convergence tolerance, in volts. 1 uV is default in Warp.
solverE = MultiGrid2D()
registersolver(solverE)

#------

# --- Emitter settings
extractor_voltage = vacuum_level
# --- Anode Location
zplate = Z_MAX#1e-6 # --- plate location

# Create source conductors
source = ZPlane(zcent=w3d.zmmin,zsign=-1.,voltage=0.)
installconductor(source, dfill=largepos)

# Create ground plate
plate = ZPlane(voltage=extractor_voltage, zcent=zplate)
installconductor(plate,dfill=largepos)

#####

{{ conductorLatticeAndParticleScraper }}

#------

particleperiod = {{ particlePeriod }}
particle_diagnostic_0 = ParticleDiagnostic(period = particleperiod, top = top, w3d = w3d,
                                           species = {species.name: species for species in listofallspecies},
                                           comm_world=comm_world, lparallel_output=False, write_dir = diagDir[:-5])
fieldperiod = {{ particlePeriod }}
efield_diagnostic_0 = FieldDiagnostic.ElectrostaticFields(solver=solverE, top=top, w3d=w3d, comm_world = comm_world,
                                                          period=fieldperiod)

installafterstep(particle_diagnostic_0.write)
installafterstep(efield_diagnostic_0.write)

#------

#prevent GIST from starting upon setup
top.lprntpara = false
top.lpsplots = false

top.verbosity = 0 # Reduce solver verbosity
solverE.mgverbose = -1 #further reduce output upon stepping - prevents websocket timeouts in Jupyter notebook
package("w3d")
generate()

#------

from warp.particles.singleparticle import TraceParticle
def get_MB_velocities(n_part, T):
    '''Return a distribution of particle velocities representing a Maxwell-Boltzmann
    distribution.

    Each velocity distribution is a temperature dependent Gaussian. Due to the geometry
    of the cathode, negative longitudinal velocities are discarded. The individual
    velocity distributions are assumed to be independent, and hence there is no covariance
    between them.

    Arguments:
    n_part (int): number of particles to be used in the distribution
    T (float): temperature of the cathode in K

    Returns:
    pos_output (ndArray): n_part x 3 array with (vx,vy,vz) values for each particle

    '''
    var_xy = kb_J*T/constants.m_e #Define the variance of the distribution in the x,y planes
    var_z = 2*kb_J*T/constants.m_e #Variance in z plane is twice that in the horizontal
    var_vs = np.asarray([var_xy,var_xy,var_z])
    mean = [0,0,0] #Each distribution has a native mean of 0.
    cov = np.multiply(var_vs,np.identity(3)) #distributions are assumed to be independent
    #mean_vz = np.sqrt(2*var/np.pi) #compute this from all-positive component of distribution

    #Additional values are computed so that tuples with negative vz can be discarded
    flag_array_full = False
    while not flag_array_full:
        output = np.random.multivariate_normal(mean,cov,int(np.round(n_part*3)))
        pos_output = output[np.where(output[:,2] > 0.)[0]]
        if pos_output.shape[0] >= n_part:
            flag_array_full = True

    return pos_output[:n_part]

electrons_tracked_t0 = Species(type=Electron)
v_coords = get_MB_velocities(PTCL_PER_STEP,CATHODE_TEMP)
x_vals = CHANNEL_WIDTH*(np.random.rand(PTCL_PER_STEP)-0.5)
y_vals = CHANNEL_WIDTH*(np.random.rand(PTCL_PER_STEP)-0.5)
z_vals = np.zeros(PTCL_PER_STEP) + Z_PART_MIN #Add a minimum z coordinate to prevent absorption
eptclArray = np.asarray([x_vals,v_coords[:,0],y_vals,v_coords[:,1],z_vals,v_coords[:,2]]).T
electron_tracker_0 = TraceParticle(js=electrons_tracked_t0.jslist[0],
                                   x=eptclArray[:,0],
                                   y=eptclArray[:,2],
                                   z=eptclArray[:,4],
                                   vx=np.zeros_like(eptclArray[:,0]),
                                   vy=np.zeros_like(eptclArray[:,0]),
                                   vz=eptclArray[:,5])

def particle_trace(trace,ntrack):
    kept_electronsx = []
    kept_electronsz = []
    lost_electronsx = []
    lost_electronsz = []
    for electron in range(ntrack):
        for step in range(len(trace.getx(i=electron)) - 1):
            if abs(trace.getx(i=electron)[step] -
                   trace.getx(i=electron)[step + 1]) > (X_MAX - X_MIN) / 2.:
                lost_electronsx.append(trace.getx(i=electron)[0:step])
                lost_electronsz.append(trace.getz(i=electron)[0:step])
                break
            if step == (len(trace.getx(i=electron)) - 2):
                kept_electronsx.append(trace.getx(i=electron))
                kept_electronsz.append(trace.getz(i=electron))
    return [kept_electronsx,kept_electronsz], [lost_electronsx,lost_electronsz]

#------

#%%time
num_steps = {{ simulationGrid_num_steps }}
output_steps = np.linspace(0,num_steps,num_steps/particleperiod + 1)[1:]
step_count = 0
time0 = time.time()
#CATHODE_TEMP, CHANNEL_WIDTH, Z_PART_MIN, ptcl_per_step
#step(num_steps, cathode_temp = CATHODE_TEMP, channel_width=CHANNEL_WIDTH, z_part_min=Z_PART_MIN, ptcl_per_step=ptcl_per_step)
step(num_steps)
time1 = time.time()
time_per_step = (time1-time0)/num_steps

kept_electrons, lost_electrons = particle_trace(electron_tracker_0, electron_tracker_0.nn)
np.save('{{ particleFile }}', [kept_electrons, lost_electrons])
